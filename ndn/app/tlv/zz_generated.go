// Code generated by ndn tlv codegen DO NOT EDIT.
package tlv

import (
	"encoding/binary"
	"io"
	"strings"

	enc "github.com/named-data/ndnd/std/encoding"
)

type MessageEncoder struct {
	Length uint

	YjsDelta_encoder    YjsDeltaEncoder
	DSKRequest_encoder  DSKRequestEncoder
	DSKResponse_encoder DSKResponseEncoder
	DSKACK_encoder      DSKACKEncoder
}

type MessageParsingContext struct {
	YjsDelta_context    YjsDeltaParsingContext
	DSKRequest_context  DSKRequestParsingContext
	DSKResponse_context DSKResponseParsingContext
	DSKACK_context      DSKACKParsingContext
}

func (encoder *MessageEncoder) Init(value *Message) {
	if value.YjsDelta != nil {
		encoder.YjsDelta_encoder.Init(value.YjsDelta)
	}
	if value.DSKRequest != nil {
		encoder.DSKRequest_encoder.Init(value.DSKRequest)
	}
	if value.DSKResponse != nil {
		encoder.DSKResponse_encoder.Init(value.DSKResponse)
	}
	if value.DSKACK != nil {
		encoder.DSKACK_encoder.Init(value.DSKACK)
	}

	l := uint(0)
	if value.YjsDelta != nil {
		l += 1
		l += uint(enc.TLNum(encoder.YjsDelta_encoder.Length).EncodingLength())
		l += encoder.YjsDelta_encoder.Length
	}
	if value.DSKRequest != nil {
		l += 1
		l += uint(enc.TLNum(encoder.DSKRequest_encoder.Length).EncodingLength())
		l += encoder.DSKRequest_encoder.Length
	}
	if value.DSKResponse != nil {
		l += 1
		l += uint(enc.TLNum(encoder.DSKResponse_encoder.Length).EncodingLength())
		l += encoder.DSKResponse_encoder.Length
	}
	if value.DSKACK != nil {
		l += 1
		l += uint(enc.TLNum(encoder.DSKACK_encoder.Length).EncodingLength())
		l += encoder.DSKACK_encoder.Length
	}
	encoder.Length = l

}

func (context *MessageParsingContext) Init() {
	context.YjsDelta_context.Init()
	context.DSKRequest_context.Init()
	context.DSKResponse_context.Init()
	context.DSKACK_context.Init()
}

func (encoder *MessageEncoder) EncodeInto(value *Message, buf []byte) {

	pos := uint(0)

	if value.YjsDelta != nil {
		buf[pos] = byte(200)
		pos += 1
		pos += uint(enc.TLNum(encoder.YjsDelta_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.YjsDelta_encoder.Length > 0 {
			encoder.YjsDelta_encoder.EncodeInto(value.YjsDelta, buf[pos:])
			pos += encoder.YjsDelta_encoder.Length
		}
	}
	if value.DSKRequest != nil {
		buf[pos] = byte(202)
		pos += 1
		pos += uint(enc.TLNum(encoder.DSKRequest_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.DSKRequest_encoder.Length > 0 {
			encoder.DSKRequest_encoder.EncodeInto(value.DSKRequest, buf[pos:])
			pos += encoder.DSKRequest_encoder.Length
		}
	}
	if value.DSKResponse != nil {
		buf[pos] = byte(204)
		pos += 1
		pos += uint(enc.TLNum(encoder.DSKResponse_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.DSKResponse_encoder.Length > 0 {
			encoder.DSKResponse_encoder.EncodeInto(value.DSKResponse, buf[pos:])
			pos += encoder.DSKResponse_encoder.Length
		}
	}
	if value.DSKACK != nil {
		buf[pos] = byte(206)
		pos += 1
		pos += uint(enc.TLNum(encoder.DSKACK_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.DSKACK_encoder.Length > 0 {
			encoder.DSKACK_encoder.EncodeInto(value.DSKACK, buf[pos:])
			pos += encoder.DSKACK_encoder.Length
		}
	}
}

func (encoder *MessageEncoder) Encode(value *Message) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *MessageParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*Message, error) {

	var handled_YjsDelta bool = false
	var handled_DSKRequest bool = false
	var handled_DSKResponse bool = false
	var handled_DSKACK bool = false

	progress := -1
	_ = progress

	value := &Message{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 200:
				if true {
					handled = true
					handled_YjsDelta = true
					value.YjsDelta, err = context.YjsDelta_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 202:
				if true {
					handled = true
					handled_DSKRequest = true
					value.DSKRequest, err = context.DSKRequest_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 204:
				if true {
					handled = true
					handled_DSKResponse = true
					value.DSKResponse, err = context.DSKResponse_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 206:
				if true {
					handled = true
					handled_DSKACK = true
					value.DSKACK, err = context.DSKACK_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_YjsDelta && err == nil {
		value.YjsDelta = nil
	}
	if !handled_DSKRequest && err == nil {
		value.DSKRequest = nil
	}
	if !handled_DSKResponse && err == nil {
		value.DSKResponse = nil
	}
	if !handled_DSKACK && err == nil {
		value.DSKACK = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *Message) Encode() enc.Wire {
	encoder := MessageEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *Message) Bytes() []byte {
	return value.Encode().Join()
}

func ParseMessage(reader enc.WireView, ignoreCritical bool) (*Message, error) {
	context := MessageParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type YjsDeltaEncoder struct {
	Length uint
}

type YjsDeltaParsingContext struct {
}

func (encoder *YjsDeltaEncoder) Init(value *YjsDelta) {

	l := uint(0)
	l += 3
	l += uint(enc.TLNum(len(value.UUID)).EncodingLength())
	l += uint(len(value.UUID))
	if value.Binary != nil {
		l += 3
		l += uint(enc.TLNum(len(value.Binary)).EncodingLength())
		l += uint(len(value.Binary))
	}
	encoder.Length = l

}

func (context *YjsDeltaParsingContext) Init() {

}

func (encoder *YjsDeltaEncoder) EncodeInto(value *YjsDelta, buf []byte) {

	pos := uint(0)

	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(1144))
	pos += 3
	pos += uint(enc.TLNum(len(value.UUID)).EncodeInto(buf[pos:]))
	copy(buf[pos:], value.UUID)
	pos += uint(len(value.UUID))
	if value.Binary != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(1200))
		pos += 3
		pos += uint(enc.TLNum(len(value.Binary)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.Binary)
		pos += uint(len(value.Binary))
	}
}

func (encoder *YjsDeltaEncoder) Encode(value *YjsDelta) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *YjsDeltaParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*YjsDelta, error) {

	var handled_UUID bool = false
	var handled_Binary bool = false

	progress := -1
	_ = progress

	value := &YjsDelta{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 1144:
				if true {
					handled = true
					handled_UUID = true
					{
						var builder strings.Builder
						_, err = reader.CopyN(&builder, int(l))
						if err == nil {
							value.UUID = builder.String()
						}
					}
				}
			case 1200:
				if true {
					handled = true
					handled_Binary = true
					value.Binary = make([]byte, l)
					_, err = reader.ReadFull(value.Binary)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_UUID && err == nil {
		err = enc.ErrSkipRequired{Name: "UUID", TypeNum: 1144}
	}
	if !handled_Binary && err == nil {
		value.Binary = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *YjsDelta) Encode() enc.Wire {
	encoder := YjsDeltaEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *YjsDelta) Bytes() []byte {
	return value.Encode().Join()
}

func ParseYjsDelta(reader enc.WireView, ignoreCritical bool) (*YjsDelta, error) {
	context := YjsDeltaParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type DSKRequestEncoder struct {
	Length uint
}

type DSKRequestParsingContext struct {
}

func (encoder *DSKRequestEncoder) Init(value *DSKRequest) {

	l := uint(0)
	if value.X25519Pub != nil {
		l += 3
		l += uint(enc.TLNum(len(value.X25519Pub)).EncodingLength())
		l += uint(len(value.X25519Pub))
	}
	l += 3
	l += uint(1 + enc.Nat(value.Expiry).EncodingLength())
	encoder.Length = l

}

func (context *DSKRequestParsingContext) Init() {

}

func (encoder *DSKRequestEncoder) EncodeInto(value *DSKRequest, buf []byte) {

	pos := uint(0)

	if value.X25519Pub != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(1400))
		pos += 3
		pos += uint(enc.TLNum(len(value.X25519Pub)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.X25519Pub)
		pos += uint(len(value.X25519Pub))
	}
	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(1402))
	pos += 3

	buf[pos] = byte(enc.Nat(value.Expiry).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
}

func (encoder *DSKRequestEncoder) Encode(value *DSKRequest) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *DSKRequestParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*DSKRequest, error) {

	var handled_X25519Pub bool = false
	var handled_Expiry bool = false

	progress := -1
	_ = progress

	value := &DSKRequest{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 1400:
				if true {
					handled = true
					handled_X25519Pub = true
					value.X25519Pub = make([]byte, l)
					_, err = reader.ReadFull(value.X25519Pub)
				}
			case 1402:
				if true {
					handled = true
					handled_Expiry = true
					value.Expiry = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Expiry = uint64(value.Expiry<<8) | uint64(x)
						}
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_X25519Pub && err == nil {
		value.X25519Pub = nil
	}
	if !handled_Expiry && err == nil {
		err = enc.ErrSkipRequired{Name: "Expiry", TypeNum: 1402}
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *DSKRequest) Encode() enc.Wire {
	encoder := DSKRequestEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *DSKRequest) Bytes() []byte {
	return value.Encode().Join()
}

func ParseDSKRequest(reader enc.WireView, ignoreCritical bool) (*DSKRequest, error) {
	context := DSKRequestParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type DSKResponseEncoder struct {
	Length uint
}

type DSKResponseParsingContext struct {
}

func (encoder *DSKResponseEncoder) Init(value *DSKResponse) {

	l := uint(0)
	if value.X25519Peer != nil {
		l += 3
		l += uint(enc.TLNum(len(value.X25519Peer)).EncodingLength())
		l += uint(len(value.X25519Peer))
	}
	if value.Ciphertext != nil {
		l += 3
		l += uint(enc.TLNum(len(value.Ciphertext)).EncodingLength())
		l += uint(len(value.Ciphertext))
	}
	encoder.Length = l

}

func (context *DSKResponseParsingContext) Init() {

}

func (encoder *DSKResponseEncoder) EncodeInto(value *DSKResponse, buf []byte) {

	pos := uint(0)

	if value.X25519Peer != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(1402))
		pos += 3
		pos += uint(enc.TLNum(len(value.X25519Peer)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.X25519Peer)
		pos += uint(len(value.X25519Peer))
	}
	if value.Ciphertext != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(1404))
		pos += 3
		pos += uint(enc.TLNum(len(value.Ciphertext)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.Ciphertext)
		pos += uint(len(value.Ciphertext))
	}
}

func (encoder *DSKResponseEncoder) Encode(value *DSKResponse) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *DSKResponseParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*DSKResponse, error) {

	var handled_X25519Peer bool = false
	var handled_Ciphertext bool = false

	progress := -1
	_ = progress

	value := &DSKResponse{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 1402:
				if true {
					handled = true
					handled_X25519Peer = true
					value.X25519Peer = make([]byte, l)
					_, err = reader.ReadFull(value.X25519Peer)
				}
			case 1404:
				if true {
					handled = true
					handled_Ciphertext = true
					value.Ciphertext = make([]byte, l)
					_, err = reader.ReadFull(value.Ciphertext)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_X25519Peer && err == nil {
		value.X25519Peer = nil
	}
	if !handled_Ciphertext && err == nil {
		value.Ciphertext = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *DSKResponse) Encode() enc.Wire {
	encoder := DSKResponseEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *DSKResponse) Bytes() []byte {
	return value.Encode().Join()
}

func ParseDSKResponse(reader enc.WireView, ignoreCritical bool) (*DSKResponse, error) {
	context := DSKResponseParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type DSKACKEncoder struct {
	Length uint
}

type DSKACKParsingContext struct {
}

func (encoder *DSKACKEncoder) Init(value *DSKACK) {

	l := uint(0)
	if value.X25519Peer != nil {
		l += 3
		l += uint(enc.TLNum(len(value.X25519Peer)).EncodingLength())
		l += uint(len(value.X25519Peer))
	}
	encoder.Length = l

}

func (context *DSKACKParsingContext) Init() {

}

func (encoder *DSKACKEncoder) EncodeInto(value *DSKACK, buf []byte) {

	pos := uint(0)

	if value.X25519Peer != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(1402))
		pos += 3
		pos += uint(enc.TLNum(len(value.X25519Peer)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.X25519Peer)
		pos += uint(len(value.X25519Peer))
	}
}

func (encoder *DSKACKEncoder) Encode(value *DSKACK) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *DSKACKParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*DSKACK, error) {

	var handled_X25519Peer bool = false

	progress := -1
	_ = progress

	value := &DSKACK{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 1402:
				if true {
					handled = true
					handled_X25519Peer = true
					value.X25519Peer = make([]byte, l)
					_, err = reader.ReadFull(value.X25519Peer)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_X25519Peer && err == nil {
		value.X25519Peer = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *DSKACK) Encode() enc.Wire {
	encoder := DSKACKEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *DSKACK) Bytes() []byte {
	return value.Encode().Join()
}

func ParseDSKACK(reader enc.WireView, ignoreCritical bool) (*DSKACK, error) {
	context := DSKACKParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}
